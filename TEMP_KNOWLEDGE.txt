TEMP KNOWLEDGE LOG - 2025-11-07
================================
1. storage.js (js/storage/storage.js) owns all localStorage access layers and prints the verbose logs shown in the console snippet, including Storage.isFinalOutputVerified and Storage.saveFinalOutput.
2. loop-controller.js (js/control/loop-controller.js) runs the main iteration loop and logs POST-ITERATION checks, scheduling, and session state which matches the provided console output lines ~457-484.
3. JSExecutor (js/execution/js-executor.js) queues JS code, records executions into the reasoning log, and currently persists raw code/error details simply as markdown text blocks.
4. ToolOperationPipeline + processors (js/reasoning/tools/...) convert parsed LLM operations into Storage mutations; js-execute-processor funnels code to JSExecutor, and final-output-processor-v2 handles vault resolution + verification before writing Storage.saveFinalOutput(true).
5. Renderer.renderReasoningLog (js/ui/renderer/renderer-reasoning.js) pulls Storage.loadReasoningLog() entries, pipes them through marked markdown rendering, and alternates block styling; code/console output strings are not currently wrapped in <pre> which causes markdown interpretation.
6. ReasoningSessionManager + ChainHealthMonitor provide bookkeeping for iteration counts, error metrics, and middleware hooks (on session.middleware) that we can leverage for injecting transient instructions if needed.
7. There is no existing mechanism for a transient "pending execution error context"; errors are appended to reasoning log entries permanently, so implementing the requested contextual cleanup will require a new storage slot + prompt injection + lifecycle hooks.
\n[2025-11-07T21:20Z] Observed ReasoningSessionManager.shouldContinue() gating uses last 5 errors regardless of success, causing premature shutdown after a handful of non-consecutive errors. JSExecutor still writes failing code into reasoning log, leaving error snippets forever despite new pending-error mechanism.
[2025-11-07T22:05Z] Formatting truncation traced to regex patterns for self-closing tool tags (memory/task/goal/datavault) using [^>]* to capture attributes. Whenever attribute values contain '>' or line breaks (common in Markdown/code), the parser stops at the first '>' and drops the rest of the content, so Storage entities and final outputs get chopped mid-sentence.
[2025-11-07T22:24Z] Completed full scan of tool-registry + unified parser + processors; self-closing patterns live in one file, parseAttributes still uses regex that ignores escaped quotes, and VaultResolutionService only touches final_output after parsing, so truncation must be resolved at the parser stage before entities ever hit storage.
[2025-11-07T22:40Z] Regex builders + attribute state machine implemented; telemetry now warns when operations look truncated, providing quick visibility if the LLM emits malformed tool tags.
