<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="css/site/styles.css">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Digi-Key MPN Analyzer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <div class="nav__item">
                <a href="index.html" class="back-link">Back to Tools</a>
            </div>
        </nav>
        
        <header class="page-header">
            <div>
                <h1 class="page-header__title">Digi-Key MPN Analyzer</h1>
                <p class="lead">Parallel processing with multiple API credentials</p>
            </div>
            <div class="page-header__meta">
                <div class="meta">Credentials: <span id="credCount">0</span></div>
                <div class="meta">Workers: <span id="workerCount">0</span></div>
                <div id="authStatus" class="meta text-warning" style="display: none;">ðŸ”„ Authenticating...</div>
            </div>
        </header>

        <section class="mb-48">
            <h2 class="mb-16">Credentials</h2>
            
            <div class="grid-12 gap-16 mb-16">
                <div class="col-span-6">
                    <div class="form__group">
                        <label class="label">Client ID</label>
                        <input type="text" id="clientId" autocomplete="off" class="input">
                    </div>
                </div>
                <div class="col-span-6">
                    <div class="form__group">
                        <label class="label">Client Secret</label>
                        <input type="password" id="clientSecret" autocomplete="off" class="input">
                    </div>
                </div>
            </div>
            
            <div class="grid-12 gap-16 mb-16">
                <div class="col-span-6">
                    <div class="form__group">
                        <label class="label">Label</label>
                        <input type="text" id="credLabel" placeholder="Optional" class="input">
                    </div>
                </div>
                <div class="col-span-6">
                    <div class="form__group">
                        <label class="label">Environment</label>
                        <select id="environment" class="select">
                            <option value="production">Production</option>
                            <option value="sandbox">Sandbox</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="form__group mb-16">
                <label class="label">Locale</label>
                <select id="locale" class="select">
                    <option value="US/USD">US / USD</option>
                    <option value="CA/CAD">CA / CAD</option>
                    <option value="GB/GBP">GB / GBP</option>
                    <option value="DE/EUR">DE / EUR</option>
                    <option value="JP/JPY">JP / JPY</option>
                </select>
            </div>
            
            <div class="button-group mb-16">
                <button id="addCred" class="button button--primary">Add</button>
                <button id="authAll" class="button button--ghost">Authenticate All</button>
                <button id="clearCreds" class="button button--ghost text-error">Clear All</button>
            </div>
            
            <div id="credList" class="mt-16"></div>
        </section>

        <section class="mb-48">
            <h2 class="mb-16">Processing</h2>
            
            <div class="alert alert--info mb-16">
                <div class="alert__msg">
                    Parallel processing distributes requests across multiple authenticated credentials to maximize throughput while respecting API rate limits. Authentication happens automatically when needed.
                </div>
            </div>
            
            <div class="form__group mb-16">
                <label class="label">MPNs (one per line)</label>
                <textarea id="mpnInput" placeholder="ECA-1VHG102&#10;STM32F103C8T6&#10;LM358P" class="textarea"></textarea>
            </div>
            
            <div class="form__group mb-16">
                <label class="label">Concurrency per Credential</label>
                <input type="number" id="concurrency" value="3" min="1" max="10" class="input">
                <div class="form__help">Recommended: 2-5</div>
            </div>
            
            <div id="progress" class="card mb-16 hidden">
                <div class="card__header">
                    <h3 class="card__title">Processing Progress</h3>
                </div>
                <div class="p-16">
                    <div id="progressText" class="font-mono text-xs mb-8"></div>
                    <div class="progress mb-16">
                        <div id="progressBar" class="progress__bar"></div>
                    </div>
                    <div class="stats">
                        <div class="text-center">
                            <div class="stat__value" id="statProcessed">0</div>
                            <div class="stat__label">Processed</div>
                        </div>
                        <div class="text-center">
                            <div class="stat__value" id="statSuccess">0</div>
                            <div class="stat__label">Success</div>
                        </div>
                        <div class="text-center">
                            <div class="stat__value" id="statWarning">0</div>
                            <div class="stat__label">Warning</div>
                        </div>
                        <div class="text-center">
                            <div class="stat__value" id="statError">0</div>
                            <div class="stat__label">Error</div>
                        </div>
                        <div class="text-center">
                            <div class="stat__value" id="statRate">0/s</div>
                            <div class="stat__label">Rate</div>
                        </div>
                        <div class="text-center">
                            <div class="stat__value" id="statETA">--</div>
                            <div class="stat__label">ETA</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button id="process" class="button button--primary">Process</button>
                <button id="export" class="button button--ghost" disabled>Export CSV</button>
                <button id="clear" class="button button--ghost">Clear Results</button>
            </div>
        </section>

        <section class="mb-48">
            <h2 class="mb-16">Results</h2>
            <div id="resultsArea">
                <div id="emptyResults" class="card">
                    <div class="p-24 text-center text-gray-500">No results yet</div>
                </div>
                <div id="resultsTable" class="results-table hidden"></div>
            </div>
        </section>

        <section class="mb-48">
            <h2 class="mb-16">Log</h2>
            <div id="log" class="log">System initialized - Auto-authentication enabled</div>
        </section>
    </div>

    <!-- Keep the existing JavaScript as-is since it's working -->
    <script>
(function() {
    'use strict';

    // Configuration
    const CONFIG = {
        PRODUCTION: {
            BASE_URL: 'https://api.digikey.com',
            TOKEN_URL: 'https://api.digikey.com/v1/oauth2/token'
        },
        SANDBOX: {
            BASE_URL: 'https://sandbox-api.digikey.com',
            TOKEN_URL: 'https://sandbox-api.digikey.com/v1/oauth2/token'
        },
        STORAGE_KEY: 'dk_creds',
        MIN_DELAY: 100,
        TOKEN_BUFFER: 300000, // 5 minutes before expiry
        MAX_RETRIES: 3,
        RETRY_DELAY: 1000,
        AUTH_RETRY_DELAY: 2000
    };

    // State
    const state = {
        credentials: [],
        results: [],
        isProcessing: false,
        isAuthenticating: false,
        stats: { processed: 0, success: 0, warning: 0, error: 0, startTime: 0 }
    };

    // Utilities
    const $ = id => document.getElementById(id);
    const log = (msg, type = 'info') => {
        const time = new Date().toLocaleTimeString();
        const prefix = type === 'error' ? 'âœ—' : type === 'success' ? 'âœ“' : type === 'warning' ? 'âš ' : 'â€¢';
        $('log').textContent += `\n[${time}] ${prefix} ${msg}`;
        $('log').scrollTop = $('log').scrollHeight;
    };
    const uid = () => Math.random().toString(36).substr(2, 9);
    
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

    // Credential Manager
    class CredentialManager {
        constructor() {
            this.load();
            this.render();
        }

        add(clientId, clientSecret, env, locale, label) {
            if (!clientId || !clientSecret) {
                log('Cannot add credential: Missing Client ID or Secret', 'error');
                return null;
            }
            
            const cred = {
                id: uid(),
                clientId: clientId.trim(),
                clientSecret: clientSecret.trim(),
                environment: env,
                locale: locale,
                label: label || `Credential ${this.count() + 1}`,
                status: 'inactive',
                token: null,
                expiry: null,
                uses: 0,
                lastError: null
            };

            state.credentials.push(cred);
            this.save();
            this.render();
            log(`Added: ${cred.label}`, 'success');
            return cred;
        }

        remove(id) {
            const idx = state.credentials.findIndex(c => c.id === id);
            if (idx > -1) {
                const cred = state.credentials.splice(idx, 1)[0];
                this.save();
                this.render();
                log(`Removed: ${cred.label}`, 'info');
            }
        }

        clear() {
            if (state.credentials.length === 0) {
                log('No credentials to clear', 'warning');
                return;
            }
            state.credentials = [];
            this.save();
            this.render();
            log('All credentials cleared', 'success');
        }

        active() {
            return state.credentials.filter(c => 
                c.status === 'active' && 
                c.token && 
                c.expiry > (Date.now() + CONFIG.TOKEN_BUFFER)
            );
        }

        needsAuth() {
            return state.credentials.filter(c => 
                !c.token || 
                c.status !== 'active' || 
                c.expiry <= (Date.now() + CONFIG.TOKEN_BUFFER)
            );
        }

        setToken(id, token, expiresIn) {
            const cred = state.credentials.find(c => c.id === id);
            if (cred) {
                cred.token = token;
                cred.expiry = Date.now() + ((expiresIn - 60) * 1000); // 1 min buffer
                cred.status = 'active';
                cred.lastError = null;
                this.render();
            }
        }

        setError(id, error) {
            const cred = state.credentials.find(c => c.id === id);
            if (cred) {
                cred.status = 'error';
                cred.lastError = error;
                this.render();
            }
        }

        markUsed(id) {
            const cred = state.credentials.find(c => c.id === id);
            if (cred) cred.uses++;
        }

        count() {
            return state.credentials.length;
        }

        save() {
            try {
                const data = state.credentials.map(c => ({
                    id: c.id,
                    clientId: c.clientId,
                    clientSecret: c.clientSecret,
                    environment: c.environment,
                    locale: c.locale,
                    label: c.label
                }));
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(data));
                this.updateMeta();
            } catch (e) {
                log(`Failed to save credentials: ${e.message}`, 'error');
            }
        }

        load() {
            try {
                const stored = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (stored) {
                    const data = JSON.parse(stored);
                    state.credentials = data.map(c => ({
                        ...c,
                        status: 'inactive',
                        token: null,
                        expiry: null,
                        uses: 0,
                        lastError: null
                    }));
                    log(`Loaded ${state.credentials.length} credential(s) from storage`, 'success');
                }
            } catch (e) {
                log(`Failed to load credentials: ${e.message}`, 'error');
            }
        }

        render() {
            const container = $('credList');
            if (!state.credentials.length) {
                container.innerHTML = '<div class="card"><div class="p-20 text-center text-gray-500">No credentials added yet</div></div>';
            } else {
                container.innerHTML = state.credentials.map(c => {
                    const active = c.status === 'active' && c.token && c.expiry > Date.now();
                    const statusText = c.status === 'error' ? `Error: ${c.lastError}` : 
                                      active ? 'Active' : 'Inactive';
                    const statusClass = c.status === 'error' ? 'badge--error' : 
                                       active ? 'badge--success' : 'badge--neutral';
                    
                    return `
                        <div class="cred">
                            <div class="cred__dot cred__dot--${active ? 'ok' : c.status === 'error' ? 'err' : 'warn'}"></div>
                            <div class="cred__info">
                                <div class="font-semibold">${c.label}</div>
                                <div class="text-xs text-gray-500">ID: ${c.clientId.substr(0, 20)}...</div>
                                <div class="text-xs text-gray-500">Env: ${c.environment} | Locale: ${c.locale}</div>
                                <div class="text-xs mt-4"><span class="badge ${statusClass}">${statusText}</span> | Uses: ${c.uses}</div>
                            </div>
                            <button class="cred__remove" onclick="cm.remove('${c.id}')">Remove</button>
                        </div>
                    `;
                }).join('');
            }
            this.updateMeta();
        }

        updateMeta() {
            $('credCount').textContent = this.count();
            $('workerCount').textContent = this.active().length;
        }
    }
    // NEW: helper to normalize HTSUS values
    function cleanHTSUS(code) {                       // ADDED: New helper to format HTSUS
        if (!code) return '';                         // ADDED: Guard for empty/undefined
        const digits = String(code).replace(/\D/g, ''); // ADDED: Keep only numeric characters
        return digits.slice(0, 8);                    // ADDED: Use only the first 8 digits
    }    

    const cm = new CredentialManager();
    window.cm = cm; // Expose for onclick handlers

    // Authentication with retry logic
    async function authenticate(cred, retryCount = 0) {
        const maxRetries = CONFIG.MAX_RETRIES;
        
        try {
            const cfg = cred.environment === 'sandbox' ? CONFIG.SANDBOX : CONFIG.PRODUCTION;
            
            log(`Authenticating ${cred.label}...`, 'info');
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout
            
            const res = await fetch(cfg.TOKEN_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    client_id: cred.clientId,
                    client_secret: cred.clientSecret,
                    grant_type: 'client_credentials'
                }),
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!res.ok) {
                const errorText = await res.text().catch(() => 'Unknown error');
                throw new Error(`HTTP ${res.status}: ${errorText}`);
            }

            const data = await res.json();
            
            if (!data.access_token || !data.expires_in) {
                throw new Error('Invalid token response: Missing access_token or expires_in');
            }

            cm.setToken(cred.id, data.access_token, data.expires_in);
            log(`âœ“ ${cred.label} authenticated successfully (expires in ${Math.floor(data.expires_in/60)}m)`, 'success');
            return true;
            
        } catch (e) {
            const errorMsg = e.name === 'AbortError' ? 'Request timeout' : e.message;
            
            if (retryCount < maxRetries) {
                log(`${cred.label} auth failed (attempt ${retryCount + 1}/${maxRetries + 1}): ${errorMsg}. Retrying...`, 'warning');
                await sleep(CONFIG.AUTH_RETRY_DELAY * (retryCount + 1));
                return authenticate(cred, retryCount + 1);
            } else {
                cm.setError(cred.id, errorMsg);
                log(`âœ— ${cred.label} auth failed after ${maxRetries + 1} attempts: ${errorMsg}`, 'error');
                return false;
            }
        }
    }

    // Auto-authenticate credentials that need auth
    async function autoAuthenticate(showStatus = true) {
        const needAuth = cm.needsAuth();
        
        if (needAuth.length === 0) {
            return true;
        }

        if (state.isAuthenticating) {
            log('Authentication already in progress...', 'warning');
            return false;
        }

        state.isAuthenticating = true;
        
        if (showStatus) {
            $('authStatus').style.display = 'block';
        }

        log(`Auto-authenticating ${needAuth.length} credential(s)...`, 'info');

        let successCount = 0;
        for (const cred of needAuth) {
            if (await authenticate(cred)) {
                successCount++;
            }
            await sleep(500); // Slight delay between auths
        }

        state.isAuthenticating = false;
        
        if (showStatus) {
            $('authStatus').style.display = 'none';
        }

        const msg = `Auto-auth complete: ${successCount}/${needAuth.length} successful`;
        log(msg, successCount > 0 ? 'success' : 'error');
        
        return successCount > 0;
    }

    // Manual authenticate all
    async function authenticateAll() {
        if (!cm.count()) {
            alert('No credentials to authenticate. Please add at least one credential.');
            return;
        }

        const btn = $('authAll');
        btn.disabled = true;
        btn.textContent = 'Authenticating...';
        $('authStatus').style.display = 'block';

        let success = 0;
        for (const cred of state.credentials) {
            if (await authenticate(cred)) success++;
            await sleep(500);
        }

        const msg = `Authentication complete: ${success}/${cm.count()} successful`;
        log(msg, success > 0 ? 'success' : 'error');
        
        btn.disabled = false;
        btn.textContent = 'Authenticate All';
        $('authStatus').style.display = 'none';

        if (success === 0) {
            alert('All authentication attempts failed. Please check your credentials and network connection.');
        }
    }

    // API Functions with error handling
    function getHeaders(cred) {
        const [site, currency] = cred.locale.split('/');
        return {
            'Content-Type': 'application/json',
            'X-DIGIKEY-Client-Id': cred.clientId,
            'Authorization': `Bearer ${cred.token}`,
            'X-DIGIKEY-Locale-Site': site,
            'X-DIGIKEY-Locale-Language': 'en',
            'X-DIGIKEY-Locale-Currency': currency
        };
    }

    async function apiCallWithRetry(fn, retries = CONFIG.MAX_RETRIES) {
        for (let i = 0; i <= retries; i++) {
            try {
                return await fn();
            } catch (e) {
                if (i === retries) throw e;
                
                // Don't retry on 404 or 400
                if (e.message.includes('404') || e.message.includes('400')) throw e;
                
                log(`API call failed (attempt ${i + 1}/${retries + 1}): ${e.message}. Retrying...`, 'warning');
                await sleep(CONFIG.RETRY_DELAY * (i + 1));
            }
        }
    }

    async function productDetails(cred, mpn) {
        return apiCallWithRetry(async () => {
            const cfg = cred.environment === 'sandbox' ? CONFIG.SANDBOX : CONFIG.PRODUCTION;
            const url = `${cfg.BASE_URL}/products/v4/search/${encodeURIComponent(mpn)}/productdetails`;
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);
            
            const res = await fetch(url, { 
                headers: getHeaders(cred),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!res.ok) {
                const errorText = await res.text().catch(() => '');
                throw new Error(`API ${res.status}: ${errorText || res.statusText}`);
            }
            
            cm.markUsed(cred.id);
            return res.json();
        });
    }

    async function keywordSearch(cred, keyword) {
        return apiCallWithRetry(async () => {
            const cfg = cred.environment === 'sandbox' ? CONFIG.SANDBOX : CONFIG.PRODUCTION;
            const url = `${cfg.BASE_URL}/products/v4/search/keyword`;
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);
            
            const res = await fetch(url, {
                method: 'POST',
                headers: getHeaders(cred),
                body: JSON.stringify({
                    Keywords: keyword,
                    RecordCount: 20,
                    RecordStartPosition: 0,
                    Filters: {},
                    Sort: { Option: "SortByManu", Direction: "Ascending", SortParameterId: 0 }
                }),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!res.ok) {
                const errorText = await res.text().catch(() => '');
                throw new Error(`API ${res.status}: ${errorText || res.statusText}`);
            }
            
            cm.markUsed(cred.id);
            return res.json();
        });
    }

    // Data extraction with safe fallbacks
    function extractParam(params, names) {
        try {
            if (!Array.isArray(params)) return '';
            const p = params.find(p => 
                p && p.ParameterText && names.some(n => 
                    p.ParameterText.toLowerCase().includes(n.toLowerCase())
                )
            );
            return p?.ValueText || '';
        } catch (e) {
            return '';
        }
    }

    function extractDatasheet(product) {
        try {
            // Try multiple possible datasheet fields
            return product.PrimaryDatasheet || 
                   product.DatasheetUrl || 
                   product.Datasheets?.[0]?.Url || 
                   product.DatasheetURL ||
                   '';
        } catch (e) {
            return '';
        }
    }

    // Process single MPN with comprehensive error handling
    async function processMPN(mpn, cred) {
        if (!mpn || !mpn.trim()) {
            return {
                status: 'error',
                mpn: mpn || 'EMPTY',
                description: '',
                detailed: '',
                category: '',
                manufacturer: '',
                package: '',
                mounting: '',
                datasheet: '',
                aliases: '',
                remarks: 'Empty MPN',
                htsus: ''                             // ADDED: Include HTSUS field in error object
            };
        }

        const cleanMpn = mpn.trim();

        try {
            // Check if credential needs re-authentication
            if (!cred.token || cred.expiry <= (Date.now() + CONFIG.TOKEN_BUFFER)) {
                log(`Token expired for ${cred.label}, attempting re-auth...`, 'warning');
                const authSuccess = await authenticate(cred);
                if (!authSuccess) {
                    throw new Error('Re-authentication failed');
                }
            }

            // Try direct lookup first
            try {
                const data = await productDetails(cred, cleanMpn);
                if (data?.Product) {
                    const p = data.Product;
                    return {
                        status: 'success',
                        mpn: cleanMpn,
                        description: p.Description?.ProductDescription || '',
                        detailed: p.Description?.DetailedDescription || '',
                        categzory: p.Category?.Name || '',           // NOTE: kept original key as-is
                        manufacturer: p.Manufacturer?.Name || '',
                        package: extractParam(p.Parameters, ['Package', 'Case']),
                        mounting: extractParam(p.Parameters, ['Mounting', 'Mounting Type']),
                        datasheet: extractDatasheet(p),
                        aliases: Array.isArray(p.OtherNames) ? p.OtherNames.join(', ') : '',
                        remarks: `Direct match via ${cred.label}`,
                        htsus: cleanHTSUS(p.Classifications?.HtsusCode) // ADDED: Capture and normalize HTSUS
                    };
                }
            } catch (e) {
                // If direct lookup fails, try keyword search
                if (!e.message.includes('404')) {
                    log(`Direct lookup failed for ${cleanMpn}, trying keyword search: ${e.message}`, 'warning');
                }
            }

            // Keyword search fallback
            const searchData = await keywordSearch(cred, cleanMpn);
            const products = searchData?.Products || [];
            const exact = searchData?.ExactMatches || [];

            let match = null;
            let matchType = '';

            // Priority: Exact match > Direct MPN match > Alias match > First result
            if (exact.length > 0) {
                match = exact[0];
                matchType = 'Exact';
            } else {
                match = products.find(p => 
                    p.ManufacturerProductNumber?.toUpperCase() === cleanMpn.toUpperCase()
                );
                if (match) matchType = 'Direct';
            }

            if (!match) {
                match = products.find(p => 
                    p.OtherNames && p.OtherNames.some(name => 
                        name.toUpperCase() === cleanMpn.toUpperCase()
                    )
                );
                if (match) matchType = 'Alias';
            }

            if (!match && products.length > 0) {
                match = products[0];
                matchType = 'Partial';
            }

            if (match) {
                return {
                    status: matchType === 'Partial' ? 'warning' : 'success',
                    mpn: cleanMpn,
                    description: match.Description?.ProductDescription || '',
                    detailed: match.Description?.DetailedDescription || '',
                    category: match.Category?.Name || '',
                    manufacturer: match.Manufacturer?.Name || '',
                    package: extractParam(match.Parameters, ['Package', 'Case']),
                    mounting: extractParam(match.Parameters, ['Mounting', 'Mounting Type']),
                    datasheet: extractDatasheet(match),
                    aliases: Array.isArray(match.OtherNames) ? match.OtherNames.join(', ') : '',
                    remarks: `${matchType} match via ${cred.label}`,
                    htsus: cleanHTSUS(match.Classifications?.HtsusCode) // ADDED: Capture and normalize HTSUS
                };
            }

            return {
                status: 'error',
                mpn: cleanMpn,
                description: '',
                detailed: '',
                category: '',
                manufacturer: '',
                package: '',
                mounting: '',
                datasheet: '',
                aliases: '',
                remarks: `Not found (searched ${products.length} results) via ${cred.label}`,
                htsus: ''                             // ADDED: Include HTSUS field in not-found object
            };

        } catch (e) {
            const errorMsg = e.name === 'AbortError' ? 'Request timeout' : e.message;
            log(`Error processing ${cleanMpn}: ${errorMsg}`, 'error');
            
            return {
                status: 'error',
                mpn: cleanMpn,
                description: '',
                detailed: '',
                category: '',
                manufacturer: '',
                package: '',
                mounting: '',
                datasheet: '',
                aliases: '',
                remarks: `Error: ${errorMsg}`,
                htsus: ''                             // ADDED: Include HTSUS field in catch error object
            };
        }
    }




    // Parallel processor with queue management
    class ParallelProcessor {
        constructor(mpns, creds, concurrency) {
            this.mpns = [...mpns];
            this.creds = creds;
            this.concurrency = concurrency;
            this.queue = [...mpns];
            this.results = [];
            this.processing = new Set();
            this.failed = new Set();
        }

        async process(onProgress) {
            if (this.creds.length === 0) {
                throw new Error('No active credentials available');
            }

            const workers = [];
            for (const cred of this.creds) {
                for (let i = 0; i < this.concurrency; i++) {
                    workers.push(this.worker(cred, onProgress));
                }
            }
            
            await Promise.all(workers);
            return this.results;
        }

        async worker(cred, onProgress) {
            while (true) {
                const mpn = this.getNext();
                if (!mpn) break;

                await sleep(CONFIG.MIN_DELAY);

                try {
                    const result = await processMPN(mpn, cred);
                    this.results.push(result);
                    if (onProgress) onProgress(result);
                } catch (e) {
                    log(`Worker error for ${mpn}: ${e.message}`, 'error');
                    this.failed.add(mpn);
                    
                    // Return error result
                    const errorResult = {
                        status: 'error',
                        mpn: mpn,
                        description: '',
                        detailed: '',
                        category: '',
                        manufacturer: '',
                        package: '',
                        mounting: '',
                        datasheet: '',
                        aliases: '',
                        remarks: `Worker error: ${e.message}`
                    };
                    this.results.push(errorResult);
                    if (onProgress) onProgress(errorResult);
                } finally {
                    this.processing.delete(mpn);
                }
            }
        }

        getNext() {
            while (this.queue.length > 0) {
                const mpn = this.queue.shift();
                if (!this.processing.has(mpn) && !this.failed.has(mpn)) {
                    this.processing.add(mpn);
                    return mpn;
                }
            }
            return null;
        }
    }

    // Process bulk with auto-authentication
    async function processBulk() {
        // Validate input
        const text = $('mpnInput').value.trim();
        if (!text) {
            alert('Please enter at least one MPN to process.');
            return;
        }

        const mpns = text.split('\n')
            .map(m => m.trim())
            .filter(m => m && m.length > 0);
            
        if (!mpns.length) {
            alert('No valid MPNs found. Please enter at least one MPN.');
            return;
        }

        // Check credentials
        if (!cm.count()) {
            alert('No credentials added. Please add at least one set of API credentials before processing.');
            return;
        }

        // Auto-authenticate if needed
        log('Checking authentication status...', 'info');
        const authSuccess = await autoAuthenticate(true);
        
        const active = cm.active();
        if (active.length === 0) {
            alert('No credentials are currently authenticated. Please check your credentials and try again.');
            return;
        }

        const concurrency = parseInt($('concurrency').value) || 3;
        
        if (concurrency < 1 || concurrency > 10) {
            alert('Concurrency must be between 1 and 10.');
            return;
        }

        // Reset state
        state.results = [];
        state.stats = { processed: 0, success: 0, warning: 0, error: 0, startTime: Date.now() };
        $('emptyResults').classList.add('hidden');
        $('resultsTable').innerHTML = '';
        $('resultsTable').classList.add('hidden');
        $('progress').classList.remove('hidden');
        $('export').disabled = true;

        const btn = $('process');
        btn.disabled = true;
        btn.textContent = 'Processing...';
        state.isProcessing = true;

        try {
            log(`Starting batch process: ${mpns.length} MPN(s) with ${active.length} credential(s), concurrency: ${concurrency}`, 'success');

            const processor = new ParallelProcessor(mpns, active, concurrency);

            const onProgress = (result) => {
                state.results.push(result);
                addResult(result);
                
                state.stats.processed++;
                if (result.status === 'success') state.stats.success++;
                else if (result.status === 'warning') state.stats.warning++;
                else state.stats.error++;

                updateProgress(state.stats.processed, mpns.length);
            };

            await processor.process(onProgress);
            
            const elapsed = ((Date.now() - state.stats.startTime) / 1000).toFixed(1);
            log(`âœ“ Batch complete: ${mpns.length} processed in ${elapsed}s (${state.stats.success} success, ${state.stats.warning} warning, ${state.stats.error} error)`, 'success');

        } catch (e) {
            log(`âœ— Batch processing error: ${e.message}`, 'error');
            alert(`Processing failed: ${e.message}`);
        } finally {
            state.isProcessing = false;
            btn.disabled = false;
            btn.textContent = 'Process';
            $('export').disabled = false;
        }
    }

    function updateProgress(current, total) {
        const pct = Math.round((current / total) * 100);
        $('progressBar').style.width = pct + '%';
        $('progressText').textContent = `${current} / ${total} (${pct}%)`;

        $('statProcessed').textContent = current;
        $('statSuccess').textContent = state.stats.success;
        $('statWarning').textContent = state.stats.warning;
        $('statError').textContent = state.stats.error;

        const elapsed = (Date.now() - state.stats.startTime) / 1000;
        const rate = current / elapsed;
        $('statRate').textContent = isFinite(rate) ? rate.toFixed(1) + '/s' : '0/s';

        const remaining = total - current;
        const eta = remaining / rate;
        if (isFinite(eta) && eta > 0) {
            const m = Math.floor(eta / 60);
            const s = Math.floor(eta % 60);
            $('statETA').textContent = m > 0 ? `${m}m ${s}s` : `${s}s`;
        } else {
            $('statETA').textContent = '--';
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function addResult(r) {
        let table = $('resultsTable');
        
        if (!table.querySelector('table')) {
            table.innerHTML = `
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>MPN</th>
                            <th>Description</th>
                            <th>Detailed</th>
                            <th>Category</th>
                            <th>Manufacturer</th>
                            <th>Package</th>
                            <th>Mounting</th>
                            <th>Datasheet</th>
                            <th>Aliases</th>
                            <th>Remarks</th>
                        </tr>
                    </thead>
                    <tbody id="tbody"></tbody>
                </table>
            `;
            // ADDED: Append HTSUS header as the last column
            const headerRow = table.querySelector('thead tr');        // ADDED
            const th = document.createElement('th');                  // ADDED
            th.textContent = 'HTSUS';                                 // ADDED
            headerRow.appendChild(th);                                // ADDED

            table.classList.remove('hidden');
        }

        const tbody = $('tbody');
        const row = tbody.insertRow();
        
        const datasheetCell = r.datasheet 
            ? `<a href="${escapeHtml(r.datasheet)}" target="_blank" rel="noopener" class="link">View</a>`
            : '';
        
        const statusClass = r.status === 'success' ? 'success' : r.status === 'warning' ? 'warning' : 'error';
        const htsus = cleanHTSUS(r.htsus || '');                      // ADDED: Ensure HTSUS is 8 digits numeric only
        
        row.innerHTML = `
            <td class="status ${statusClass}">${escapeHtml(r.status)}</td>
            <td class="mono">${escapeHtml(r.mpn)}</td>
            <td>${escapeHtml(r.description)}</td>
            <td>${escapeHtml(r.detailed)}</td>
            <td>${escapeHtml(r.category)}</td>
            <td>${escapeHtml(r.manufacturer)}</td>
            <td>${escapeHtml(r.package)}</td>
            <td>${escapeHtml(r.mounting)}</td>
            <td>${datasheetCell}</td>
            <td class="mono">${escapeHtml(r.aliases)}</td>
            <td>${escapeHtml(r.remarks)}</td>
            <td class="mono">${escapeHtml(htsus)}</td>               // ADDED: New last column with 8-digit HTSUS
        `;
    }

    function clearResults() {
        if (state.results.length === 0) {
            log('No results to clear', 'warning');
            return;
        }
        
        state.results = [];
        state.stats = { processed: 0, success: 0, warning: 0, error: 0, startTime: 0 };
        $('resultsTable').innerHTML = '';
        $('resultsTable').classList.add('hidden');
        $('emptyResults').classList.remove('hidden');
        $('progress').classList.add('hidden');
        $('export').disabled = true;
        log('Results cleared', 'success');
    }

    function exportCSV() {
        if (!state.results.length) {
            alert('No results to export.');
            return;
        }

        try {
            const headers = ['Status', 'MPN', 'Description', 'Detailed', 'Category', 'Manufacturer', 'Package', 'Mounting', 'Datasheet', 'Aliases', 'Remarks','HTSUS'];
            const escape = str => `"${String(str).replace(/"/g, '""')}"`;
            
            const rows = state.results.map(r => [
                escape(r.status),
                escape(r.mpn),
                escape(r.description),
                escape(r.detailed),
                escape(r.category),
                escape(r.manufacturer),
                escape(r.package),
                escape(r.mounting),
                escape(r.datasheet),
                escape(r.aliases),
                escape(r.remarks),
                escape(cleanHTSUS(r.htsus || ''))
            ].join(','));

            const csv = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().split('T')[0];
            a.href = url;
            a.download = `digikey-mpn-analysis-${timestamp}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            log(`âœ“ Exported ${state.results.length} results to CSV`, 'success');
        } catch (e) {
            log(`âœ— Export failed: ${e.message}`, 'error');
            alert(`Failed to export CSV: ${e.message}`);
        }
    }

    // Event listeners
    $('addCred').onclick = () => {
        const id = $('clientId').value;
        const secret = $('clientSecret').value;
        const env = $('environment').value;
        const locale = $('locale').value;
        const label = $('credLabel').value;

        if (!id || !secret) {
            alert('Please enter both Client ID and Client Secret.');
            return;
        }

        const added = cm.add(id, secret, env, locale, label);
        if (added) {
            $('clientId').value = '';
            $('clientSecret').value = '';
            $('credLabel').value = '';
        }
    };

    $('authAll').onclick = authenticateAll;
    
    $('clearCreds').onclick = () => {
        if (state.credentials.length === 0) {
            alert('No credentials to clear.');
            return;
        }
        if (confirm('Clear all credentials? This will remove all saved API credentials.')) {
            cm.clear();
        }
    };
    
    $('process').onclick = processBulk;
    $('export').onclick = exportCSV;
    $('clear').onclick = clearResults;

    // Auto-authenticate on page load if credentials exist
    window.addEventListener('load', async () => {
        if (cm.count() > 0) {
            log('Page loaded with saved credentials, checking authentication...', 'info');
            await autoAuthenticate(false);
        }
        log('System ready', 'success');
    });

    log('System initialized - Ready to process MPNs', 'success');
})();
    </script>
</body>
</html>
