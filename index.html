<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Reasoning Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@400;500;600&family=Geist+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #ffffff;
            color: #000000;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 16px 24px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

            .header h1 {
                font-size: 16px;
                font-weight: 500;
                letter-spacing: -0.01em;
            }

        .header-controls {
            display: flex;
            gap: 12px;
        }

        .btn {
            font-family: 'Geist', sans-serif;
            font-size: 13px;
            padding: 6px 12px;
            background: #000000;
            color: #ffffff;
            border: 1px solid #000000;
            cursor: pointer;
            transition: all 0.2s;
        }

            .btn:hover {
                background: #ffffff;
                color: #000000;
            }

        .btn-secondary {
            background: #ffffff;
            color: #000000;
            border: 1px solid #e5e5e5;
        }

            .btn-secondary:hover {
                border-color: #000000;
            }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            border-right: 1px solid #e5e5e5;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid #e5e5e5;
        }

            .sidebar-section h3 {
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                margin-bottom: 12px;
                color: #666666;
            }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .memory-item, .goal-item {
            padding: 8px;
            margin-bottom: 8px;
            border: 1px solid #e5e5e5;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

            .memory-item:hover, .goal-item:hover {
                border-color: #000000;
            }

        .memory-summary {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .memory-preview {
            font-size: 11px;
            color: #666666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .message {
            margin-bottom: 24px;
            max-width: 800px;
        }

        .message-header {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
            color: #666666;
        }

        .message-content {
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .reasoning-step {
            padding: 12px;
            margin-bottom: 8px;
            border-left: 2px solid #e5e5e5;
            font-size: 13px;
            color: #666666;
        }

        .tool-execution {
            padding: 12px;
            margin: 8px 0;
            background: #f5f5f5;
            border-left: 2px solid #000000;
            font-family: 'Geist Mono', monospace;
            font-size: 12px;
        }

        .canvas-container {
            margin: 12px 0;
            border: 1px solid #e5e5e5;
            min-height: 200px;
        }

            .canvas-container iframe {
                width: 100%;
                height: 400px;
                border: none;
            }

        .input-container {
            padding: 16px 24px;
            border-top: 1px solid #e5e5e5;
        }

        .input-wrapper {
            display: flex;
            gap: 12px;
        }

        #userInput {
            flex: 1;
            font-family: 'Geist', sans-serif;
            font-size: 14px;
            padding: 12px;
            border: 1px solid #e5e5e5;
            resize: none;
            min-height: 44px;
            max-height: 200px;
        }

            #userInput:focus {
                outline: none;
                border-color: #000000;
            }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

            .modal.active {
                display: flex;
            }

        .modal-content {
            background: #ffffff;
            width: 90%;
            max-width: 500px;
            padding: 24px;
            border: 1px solid #000000;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 16px;
        }

        .input-group {
            margin-bottom: 16px;
        }

            .input-group label {
                display: block;
                font-size: 12px;
                font-weight: 500;
                margin-bottom: 6px;
            }

            .input-group input {
                width: 100%;
                font-family: 'Geist Mono', monospace;
                font-size: 13px;
                padding: 8px;
                border: 1px solid #e5e5e5;
            }

                .input-group input:focus {
                    outline: none;
                    border-color: #000000;
                }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .status-bar {
            padding: 8px 16px;
            background: #f5f5f5;
            font-size: 11px;
            font-family: 'Geist Mono', monospace;
            color: #666666;
            border-bottom: 1px solid #e5e5e5;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f5f5f5;
        }

        ::-webkit-scrollbar-thumb {
            background: #cccccc;
        }

            ::-webkit-scrollbar-thumb:hover {
                background: #999999;
            }
    </style>
</head>
<body>
    <div class="header">
        <h1>Gemini Reasoning Interface</h1>
        <div class="header-controls">
            <button class="btn btn-secondary" onclick="app.showApiKeys()">API Keys</button>
            <button class="btn btn-secondary" onclick="app.clearConversation()">Clear</button>
        </div>
    </div>

    <div class="status-bar" id="statusBar">Ready</div>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-section">
                <h3>Memory</h3>
                <button class="btn btn-secondary" style="width: 100%; font-size: 12px;" onclick="app.showAddMemory()">Add Memory</button>
            </div>
            <div class="sidebar-content" id="memoriesContainer"></div>

            <div class="sidebar-section">
                <h3>Goals</h3>
                <button class="btn btn-secondary" style="width: 100%; font-size: 12px;" onclick="app.showAddGoal()">Add Goal</button>
            </div>
            <div class="sidebar-content" id="goalsContainer"></div>
        </div>

        <div class="chat-container">
            <div class="messages" id="messages"></div>

            <div class="input-container">
                <div class="input-wrapper">
                    <textarea id="userInput" placeholder="Enter your message..."></textarea>
                    <button class="btn" onclick="app.sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="apiKeysModal">
        <div class="modal-content">
            <div class="modal-header">Configure API Keys</div>
            <div class="input-group">
                <label>API Key 1</label>
                <input type="password" id="apiKey1" placeholder="Enter Gemini API Key">
            </div>
            <div class="input-group">
                <label>API Key 2</label>
                <input type="password" id="apiKey2" placeholder="Enter Gemini API Key">
            </div>
            <div class="input-group">
                <label>API Key 3</label>
                <input type="password" id="apiKey3" placeholder="Enter Gemini API Key">
            </div>
            <div class="input-group">
                <label>API Key 4</label>
                <input type="password" id="apiKey4" placeholder="Enter Gemini API Key">
            </div>
            <div class="input-group">
                <label>API Key 5</label>
                <input type="password" id="apiKey5" placeholder="Enter Gemini API Key">
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="app.closeModal('apiKeysModal')">Cancel</button>
                <button class="btn" onclick="app.saveApiKeys()">Save</button>
            </div>
        </div>
    </div>

    <div class="modal" id="addMemoryModal">
        <div class="modal-content">
            <div class="modal-header">Add Memory</div>
            <div class="input-group">
                <label>Summary</label>
                <input type="text" id="memorySummary" placeholder="Brief summary">
            </div>
            <div class="input-group">
                <label>Detailed Information</label>
                <textarea id="memoryDetail" style="min-height: 100px; resize: vertical;"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="app.closeModal('addMemoryModal')">Cancel</button>
                <button class="btn" onclick="app.addMemory()">Add</button>
            </div>
        </div>
    </div>

    <div class="modal" id="addGoalModal">
        <div class="modal-content">
            <div class="modal-header">Add Goal</div>
            <div class="input-group">
                <label>Goal Description</label>
                <textarea id="goalDescription" style="min-height: 100px; resize: vertical;"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="app.closeModal('addGoalModal')">Cancel</button>
                <button class="btn" onclick="app.addGoal()">Add</button>
            </div>
        </div>
    </div>

    <script>
        const app = {
            apiKeys: [],
            currentKeyIndex: 0,
            memories: [],
            goals: [],
            reasoningChain: [],
            conversationHistory: [],

            init() {
                this.loadApiKeys();
                this.loadMemories();
                this.loadGoals();
                this.renderMemories();
                this.renderGoals();

                document.getElementById('userInput').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
            },

            loadApiKeys() {
                for (let i = 1; i <= 5; i++) {
                    const key = localStorage.getItem(`gemini_api_key_${i}`);
                    if (key) this.apiKeys.push(key);
                }
            },

            saveApiKeys() {
                this.apiKeys = [];
                for (let i = 1; i <= 5; i++) {
                    const key = document.getElementById(`apiKey${i}`).value.trim();
                    if (key) {
                        this.apiKeys.push(key);
                        localStorage.setItem(`gemini_api_key_${i}`, key);
                    }
                }
                this.closeModal('apiKeysModal');
                this.updateStatus('API keys saved');
            },

            showApiKeys() {
                for (let i = 1; i <= 5; i++) {
                    const key = localStorage.getItem(`gemini_api_key_${i}`) || '';
                    document.getElementById(`apiKey${i}`).value = key;
                }
                document.getElementById('apiKeysModal').classList.add('active');
            },

            closeModal(id) {
                document.getElementById(id).classList.remove('active');
            },

            loadMemories() {
                const stored = localStorage.getItem('gemini_memories');
                if (stored) this.memories = JSON.parse(stored);
            },

            saveMemories() {
                localStorage.setItem('gemini_memories', JSON.stringify(this.memories));
            },

            loadGoals() {
                const stored = localStorage.getItem('gemini_goals');
                if (stored) this.goals = JSON.parse(stored);
            },

            saveGoals() {
                localStorage.setItem('gemini_goals', JSON.stringify(this.goals));
            },

            showAddMemory() {
                document.getElementById('memorySummary').value = '';
                document.getElementById('memoryDetail').value = '';
                document.getElementById('addMemoryModal').classList.add('active');
            },

            addMemory() {
                const summary = document.getElementById('memorySummary').value.trim();
                const detail = document.getElementById('memoryDetail').value.trim();

                if (summary && detail) {
                    this.memories.push({ summary, detail, index: this.memories.length });
                    this.saveMemories();
                    this.renderMemories();
                    this.closeModal('addMemoryModal');
                }
            },

            showAddGoal() {
                document.getElementById('goalDescription').value = '';
                document.getElementById('addGoalModal').classList.add('active');
            },

            addGoal() {
                const description = document.getElementById('goalDescription').value.trim();

                if (description) {
                    this.goals.push({ description, index: this.goals.length });
                    this.saveGoals();
                    this.renderGoals();
                    this.closeModal('addGoalModal');
                }
            },

            renderMemories() {
                const container = document.getElementById('memoriesContainer');
                container.innerHTML = this.memories.map((mem, idx) => `
                    <div class="memory-item" onclick="app.showMemoryDetail(${idx})">
                        <div class="memory-summary">${mem.summary}</div>
                        <div class="memory-preview">${mem.detail.substring(0, 50)}...</div>
                    </div>
                `).join('');
            },

            renderGoals() {
                const container = document.getElementById('goalsContainer');
                container.innerHTML = this.goals.map((goal, idx) => `
                    <div class="goal-item">
                        <div style="font-size: 12px;">${goal.description}</div>
                    </div>
                `).join('');
            },

            showMemoryDetail(idx) {
                const mem = this.memories[idx];
                alert(`${mem.summary}\n\n${mem.detail}`);
            },

            updateStatus(msg) {
                document.getElementById('statusBar').textContent = msg;
            },

            clearConversation() {
                this.conversationHistory = [];
                this.reasoningChain = [];
                document.getElementById('messages').innerHTML = '';
                this.updateStatus('Conversation cleared');
            },

            addMessage(role, content, type = 'message') {
                const messagesDiv = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                const header = role === 'user' ? 'USER' : type === 'reasoning' ? 'REASONING' : type === 'tool' ? 'TOOL EXECUTION' : 'ASSISTANT';

                if (type === 'reasoning') {
                    messageDiv.innerHTML = `<div class="reasoning-step">${content}</div>`;
                } else if (type === 'tool') {
                    messageDiv.innerHTML = `<div class="tool-execution">${content}</div>`;
                } else if (type === 'canvas') {
                    messageDiv.innerHTML = `
                        <div class="message-header">${header}</div>
                        <div class="canvas-container">
                            <iframe srcdoc="${content.replace(/"/g, '&quot;')}"></iframe>
                        </div>
                    `;
                } else {
                    messageDiv.innerHTML = `
                        <div class="message-header">${header}</div>
                        <div class="message-content" id="msg-${Date.now()}">${content}</div>
                    `;
                }

                messagesDiv.appendChild(messageDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                return messageDiv;
            },

            async sendMessage() {
                const input = document.getElementById('userInput');
                const message = input.value.trim();

                if (!message) return;
                if (this.apiKeys.length === 0) {
                    alert('Please configure at least one API key');
                    return;
                }

                input.value = '';
                this.addMessage('user', message);
                this.conversationHistory.push({ role: 'user', content: message });
                this.reasoningChain = [];

                await this.processWithReasoning(message);
            },

            async processWithReasoning(userMessage) {
                this.updateStatus('Starting reasoning process...');

                // Step 1: Initial reasoning
                await this.reasoningStep(userMessage);

                // Step 2: Tool usage if needed
                const toolsNeeded = await this.detectTools();

                if (toolsNeeded.length > 0) {
                    for (const tool of toolsNeeded) {
                        await this.executeTool(tool);
                    }
                }

                // Step 3: Generate draft response
                const draftResponse = await this.generateDraft();

                // Step 4: Verification against goals
                const verified = await this.verifyAgainstGoals(draftResponse);

                // Step 5: Final output
                this.addMessage('assistant', verified);
                this.conversationHistory.push({ role: 'assistant', content: verified });
                this.updateStatus('Ready');
            },

            async reasoningStep(userMessage) {
                const systemPrompt = this.buildSystemPrompt('reasoning');
                const prompt = `User message: ${userMessage}\n\nProvide your chain of thought reasoning for this query. Break down your thinking step by step.`;

                const response = await this.callGemini(systemPrompt, prompt);
                this.reasoningChain.push({ step: 'initial_reasoning', content: response });
                this.addMessage('assistant', response, 'reasoning');
            },

            async detectTools() {
                const systemPrompt = this.buildSystemPrompt('tool_detection');
                const prompt = `Based on the conversation and reasoning chain, identify which external tools are needed:

Available tools in External Tools System:
- CODE_EXECUTION: Execute JavaScript code in browser
- CANVAS: Display HTML/CSS content
- MEMORY_FETCH: Retrieve detailed memory by index

Respond with a JSON array of tools needed. Format: [{"tool": "TOOL_NAME", "params": {...}}]

If no tools needed, respond with: []`;

                try {
                    const response = await this.callGemini(systemPrompt, prompt);
                    const tools = JSON.parse(response.replace(/```json\n?/g, '').replace(/```\n?/g, ''));
                    return Array.isArray(tools) ? tools : [];
                } catch (e) {
                    return [];
                }
            },

            async executeTool(tool) {
                this.updateStatus(`Executing tool: ${tool.tool}`);
                let result = '';

                switch (tool.tool) {
                    case 'CODE_EXECUTION':
                        result = await this.executeCode(tool.params.code);
                        this.addMessage('assistant', `Code:\n${tool.params.code}\n\nOutput:\n${result}`, 'tool');
                        break;

                    case 'CANVAS':
                        this.addMessage('assistant', tool.params.html, 'canvas');
                        result = 'Canvas displayed';
                        break;

                    case 'MEMORY_FETCH':
                        const mem = this.memories[tool.params.index];
                        result = mem ? mem.detail : 'Memory not found';
                        this.addMessage('assistant', `Fetched memory: ${result}`, 'tool');
                        break;
                }

                this.reasoningChain.push({ step: 'tool_execution', tool: tool.tool, result });
            },

            async executeCode(code) {
                try {
                    const logs = [];
                    const originalLog = console.log;
                    console.log = (...args) => {
                        logs.push(args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' '));
                        originalLog.apply(console, args);
                    };

                    const result = eval(code);
                    console.log = originalLog;

                    return logs.length > 0 ? logs.join('\n') : String(result);
                } catch (error) {
                    return `Error: ${error.message}`;
                }
            },

            async generateDraft() {
                const systemPrompt = this.buildSystemPrompt('draft');
                const prompt = `Generate a comprehensive response to the user's query. You have completed reasoning and tool execution. Provide the final answer.

If you used CODE_EXECUTION and want to include its output in your response, use the placeholder {{CODE_OUTPUT}} where you want it inserted.`;

                const response = await this.callGemini(systemPrompt, prompt);

                // Replace placeholders with actual outputs
                let finalResponse = response;
                const codeOutputs = this.reasoningChain.filter(r => r.step === 'tool_execution' && r.tool === 'CODE_EXECUTION');
                if (codeOutputs.length > 0 && finalResponse.includes('{{CODE_OUTPUT}}')) {
                    finalResponse = finalResponse.replace('{{CODE_OUTPUT}}', codeOutputs[codeOutputs.length - 1].result);
                }

                return finalResponse;
            },

            async verifyAgainstGoals(draft) {
                if (this.goals.length === 0) return draft;

                const systemPrompt = this.buildSystemPrompt('verification');
                const prompt = `Verify this draft response against the goals:

Draft: ${draft}

Goals:
${this.goals.map((g, i) => `${i + 1}. ${g.description}`).join('\n')}

Reasoning chain summary:
${this.reasoningChain.map(r => `- ${r.step}: ${r.content ? r.content.substring(0, 100) : r.result}`).join('\n')}

Does the draft meet all goals? If yes, return the draft as-is. If no, provide an improved version.`;

                return await this.callGemini(systemPrompt, prompt);
            },

            buildSystemPrompt(phase) {
                const memorySummaries = this.memories.map((m, i) => `[${i}] ${m.summary}`).join('\n');
                const goalsText = this.goals.map((g, i) => `${i + 1}. ${g.description}`).join('\n');

                const basePrompt = `You are a highly capable AI assistant with access to an External Tools System. You use iterative reasoning to solve problems.

AVAILABLE MEMORIES (use MEMORY_FETCH tool with index to get details):
${memorySummaries || 'None'}

CURRENT GOALS:
${goalsText || 'None'}

REASONING CHAIN SO FAR:
${this.reasoningChain.map(r => `- ${r.step}: ${JSON.stringify(r).substring(0, 200)}`).join('\n') || 'Just started'}`;

                const phasePrompts = {
                    reasoning: basePrompt + '\n\nPHASE: INITIAL REASONING\nYour task: Think through the problem step by step. Consider what information you need and what tools might help.',

                    tool_detection: basePrompt + '\n\nPHASE: TOOL DETECTION\nYour task: Analyze if you need any external tools. Respond with valid JSON only.',

                    draft: basePrompt + '\n\nPHASE: DRAFT GENERATION\nYour task: Create a comprehensive response based on all reasoning and tool outputs. Be helpful and thorough.',

                    verification: basePrompt + '\n\nPHASE: VERIFICATION\nYour task: Verify the draft meets all stated goals. If it does, return it unchanged. If not, improve it.'
                };

                return phasePrompts[phase] || basePrompt;
            },

            async callGemini(systemPrompt, userPrompt, streaming = false) {
                const apiKey = this.apiKeys[this.currentKeyIndex];

                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: `${systemPrompt}\n\n${userPrompt}` }]
                            }],
                            generationConfig: {
                                temperature: 0.7,
                                maxOutputTokens: 8192,
                            }
                        })
                    });

                    if (response.status === 429) {
                        this.currentKeyIndex = (this.currentKeyIndex + 1) % this.apiKeys.length;
                        this.updateStatus(`Rate limited, switching to key ${this.currentKeyIndex + 1}`);
                        return this.callGemini(systemPrompt, userPrompt, streaming);
                    }

                    const data = await response.json();
                    return data.candidates[0].content.parts[0].text;

                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`);
                    throw error;
                }
            }
        };

        window.onload = () => app.init();
    </script>
</body>
</html>