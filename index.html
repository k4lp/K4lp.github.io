<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini AI Interface</title>

    <!-- Geist Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&family=Geist+Mono:wght@100..900&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #ffffff;
            --surface: #f8f9fa;
            --border: #e1e4e8;
            --text: #24292e;
            --text-secondary: #586069;
            --accent: #0366d6;
            --danger: #d73a49;
            --success: #28a745;
            --warning: #ffd33d;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text);
            background: var(--bg);
            height: 100vh;
            overflow: hidden;
        }

        .interface {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: 60px 1fr;
            grid-template-areas: 
                "header header header"
                "sidebar chat panel";
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }

        .header {
            grid-area: header;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .header h1 {
            font-size: 16px;
            font-weight: 600;
        }

        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Geist Mono', monospace;
            font-size: 12px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
        }

        .status-indicator.connected {
            background: var(--success);
        }

        .sidebar {
            grid-area: sidebar;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 16px;
            background: var(--surface);
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border);
        }

        .memory-list, .goals-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .memory-item, .goal-item {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.1s;
        }

        .memory-item:hover, .goal-item:hover {
            background: var(--surface);
        }

        .memory-summary {
            font-weight: 500;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .memory-detail {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.3;
        }

        .reasoning-chain {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chain-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .chain-step {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            font-family: 'Geist Mono', monospace;
            font-size: 11px;
        }

        .step-header {
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 4px;
        }

        .chat-area {
            grid-area: chat;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .message {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        .message.user {
            background: var(--accent);
            color: white;
            align-self: flex-end;
            margin-left: auto;
        }

        .message.assistant {
            background: var(--surface);
            border: 1px solid var(--border);
            align-self: flex-start;
        }

        .message.system {
            background: var(--warning);
            color: var(--text);
            font-family: 'Geist Mono', monospace;
            font-size: 12px;
            align-self: center;
            max-width: 90%;
        }

        .chat-input {
            border-top: 1px solid var(--border);
            padding: 16px;
            background: var(--surface);
        }

        .input-container {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        .input-field {
            flex: 1;
            min-height: 40px;
            max-height: 120px;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            resize: none;
            background: var(--bg);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent);
        }

        .send-btn, .execute-btn {
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.1s;
        }

        .send-btn:hover, .execute-btn:hover {
            background: #0256cc;
        }

        .send-btn:disabled, .execute-btn:disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        .panel {
            grid-area: panel;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .panel-tab {
            padding: 12px 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.1s;
        }

        .panel-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
            background: var(--bg);
        }

        .panel-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .code-editor, .canvas-container {
            flex: 1;
            display: none;
        }

        .code-editor.active, .canvas-container.active {
            display: flex;
            flex-direction: column;
        }

        .editor-toolbar {
            padding: 8px 12px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
        }

        .code-textarea {
            flex: 1;
            font-family: 'Geist Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
            border: none;
            padding: 16px;
            background: var(--bg);
            resize: none;
            outline: none;
        }

        .canvas-frame {
            flex: 1;
            border: none;
            background: white;
        }

        .config-panel {
            padding: 16px;
            display: none;
        }

        .config-panel.active {
            display: block;
        }

        .config-group {
            margin-bottom: 16px;
        }

        .config-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .config-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: 'Geist Mono', monospace;
            font-size: 12px;
            background: var(--bg);
        }

        .config-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .add-button {
            background: var(--success);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-top: 8px;
        }

        @media (max-width: 1200px) {
            .interface {
                grid-template-columns: 250px 1fr 300px;
            }
        }

        @media (max-width: 900px) {
            .interface {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "chat";
            }

            .sidebar, .panel {
                display: none;
            }
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .error {
            color: var(--danger);
            background: #fff5f5;
            border: 1px solid var(--danger);
        }

        .success {
            color: var(--success);
            background: #f0fff4;
            border: 1px solid var(--success);
        }

        pre {
            font-family: 'Geist Mono', monospace;
            font-size: 12px;
            background: var(--surface);
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 8px 0;
        }

        code {
            font-family: 'Geist Mono', monospace;
            background: var(--surface);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 12px;
        }

        .verification-status {
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Geist Mono', monospace;
        }

        .verification-status.pending {
            background: #fff9c4;
            color: #8b5a00;
            border: 1px solid #ffd33d;
        }

        .verification-status.passed {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #16a34a;
        }

        .verification-status.failed {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
    </style>
</head>
<body>
    <div class="interface">
        <header class="header">
            <h1>Gemini AI Interface</h1>
            <div class="api-status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Disconnected</span>
            </div>
        </header>

        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="section-header">Memory Store</div>
                <div class="memory-list" id="memoryList"></div>
            </div>

            <div class="sidebar-section">
                <div class="section-header">Goals</div>
                <div class="goals-list" id="goalsList"></div>
            </div>

            <div class="sidebar-section reasoning-chain">
                <div class="section-header">Reasoning Chain</div>
                <div class="chain-list" id="reasoningChain"></div>
            </div>
        </aside>

        <main class="chat-area">
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input">
                <div class="input-container">
                    <textarea id="messageInput" class="input-field" placeholder="Ask Gemini anything..." rows="1"></textarea>
                    <button id="sendButton" class="send-btn">Send</button>
                </div>
            </div>
        </main>

        <aside class="panel">
            <div class="panel-tabs">
                <div class="panel-tab active" data-tab="code">Code</div>
                <div class="panel-tab" data-tab="canvas">Canvas</div>
                <div class="panel-tab" data-tab="config">Config</div>
            </div>

            <div class="panel-content">
                <div class="code-editor active" id="codePanel">
                    <div class="editor-toolbar">
                        <button class="execute-btn" id="executeCode">Execute JS</button>
                        <button class="execute-btn" id="clearCode">Clear</button>
                    </div>
                    <textarea id="codeEditor" class="code-textarea" placeholder="// JavaScript execution environment
// Full internet access available
// Use fetch() for HTTP requests

console.log('Ready for code execution');"></textarea>
                </div>

                <div class="canvas-container" id="canvasPanel">
                    <div class="editor-toolbar">
                        <button class="execute-btn" id="renderCanvas">Render HTML</button>
                        <button class="execute-btn" id="clearCanvas">Clear</button>
                    </div>
                    <iframe id="canvasFrame" class="canvas-frame"></iframe>
                </div>

                <div class="config-panel" id="configPanel">
                    <div class="config-group">
                        <label class="config-label" for="apiKeyInput">Gemini API Key</label>
                        <input type="password" id="apiKeyInput" class="config-input" placeholder="Enter your Gemini API key">
                    </div>

                    <div class="config-group">
                        <label class="config-label" for="modelSelect">Model</label>
                        <select id="modelSelect" class="config-input">
                            <option value="gemini-flash-latest">Gemini 2.5 Flash Latest</option>
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                            <option value="gemini-flash-lite-latest">Gemini 2.5 Flash Lite Latest</option>
                        </select>
                    </div>

                    <div class="config-group">
                        <label class="config-label" for="temperatureInput">Temperature</label>
                        <input type="range" id="temperatureInput" class="config-input" min="0" max="2" step="0.1" value="1">
                        <span id="temperatureValue">1.0</span>
                    </div>

                    <div class="config-group">
                        <label class="config-label" for="maxTokensInput">Max Tokens</label>
                        <input type="number" id="maxTokensInput" class="config-input" value="2048" min="1" max="8192">
                    </div>

                    <div class="config-group">
                        <label class="config-label" for="systemPrompt">System Instructions</label>
                        <textarea id="systemPrompt" class="config-input" rows="4" placeholder="Enter system instructions for the AI..."></textarea>
                    </div>

                    <button class="add-button" id="saveConfig">Save Configuration</button>
                </div>
            </div>
        </aside>
    </div>

    <script>
        class GeminiInterface {
            constructor() {
                this.apiKey = localStorage.getItem('gemini_api_key') || '';
                this.model = localStorage.getItem('gemini_model') || 'gemini-flash-latest';
                this.temperature = parseFloat(localStorage.getItem('gemini_temperature')) || 1.0;
                this.maxTokens = parseInt(localStorage.getItem('gemini_max_tokens')) || 2048;
                this.systemInstructions = localStorage.getItem('gemini_system') || '';

                // Data structures
                this.memoryStore = JSON.parse(localStorage.getItem('memory_store') || '[]');
                this.goalsStore = JSON.parse(localStorage.getItem('goals_store') || '[]');
                this.reasoningChain = [];
                this.conversationHistory = JSON.parse(localStorage.getItem('conversation_history') || '[]');

                // State
                this.isProcessing = false;
                this.currentVerification = null;

                this.initializeInterface();
                this.bindEvents();
                this.loadStoredData();
                this.updateStatus();
            }

            initializeInterface() {
                // Set up panel tabs
                document.querySelectorAll('.panel-tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });

                // Auto-resize textarea
                const messageInput = document.getElementById('messageInput');
                messageInput.addEventListener('input', this.autoResizeTextarea.bind(this));

                // Load saved configuration
                document.getElementById('apiKeyInput').value = this.apiKey;
                document.getElementById('modelSelect').value = this.model;
                document.getElementById('temperatureInput').value = this.temperature;
                document.getElementById('temperatureValue').textContent = this.temperature.toFixed(1);
                document.getElementById('maxTokensInput').value = this.maxTokens;
                document.getElementById('systemPrompt').value = this.systemInstructions;
            }

            bindEvents() {
                // Send message
                document.getElementById('sendButton').addEventListener('click', () => this.sendMessage());
                document.getElementById('messageInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                // Code execution
                document.getElementById('executeCode').addEventListener('click', () => this.executeCode());
                document.getElementById('clearCode').addEventListener('click', () => {
                    document.getElementById('codeEditor').value = '';
                });

                // Canvas rendering
                document.getElementById('renderCanvas').addEventListener('click', () => this.renderCanvas());
                document.getElementById('clearCanvas').addEventListener('click', () => {
                    document.getElementById('canvasFrame').src = 'about:blank';
                });

                // Configuration
                document.getElementById('saveConfig').addEventListener('click', () => this.saveConfiguration());
                document.getElementById('temperatureInput').addEventListener('input', (e) => {
                    document.getElementById('temperatureValue').textContent = parseFloat(e.target.value).toFixed(1);
                });
            }

            loadStoredData() {
                this.renderMemoryList();
                this.renderGoalsList();
                this.renderConversationHistory();
            }

            updateStatus() {
                const statusIndicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');

                if (this.apiKey) {
                    statusIndicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    statusIndicator.classList.remove('connected');
                    statusText.textContent = 'API Key Required';
                }
            }

            switchTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.panel-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });

                // Update content panels
                document.querySelectorAll('.panel-content > div').forEach(panel => {
                    panel.classList.remove('active');
                });

                const panels = {
                    'code': 'codePanel',
                    'canvas': 'canvasPanel',
                    'config': 'configPanel'
                };

                document.getElementById(panels[tabName]).classList.add('active');
            }

            autoResizeTextarea() {
                const textarea = document.getElementById('messageInput');
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            }

            async sendMessage() {
                if (this.isProcessing) return;

                const messageInput = document.getElementById('messageInput');
                const message = messageInput.value.trim();

                if (!message) return;
                if (!this.apiKey) {
                    this.showSystemMessage('Please configure your API key first');
                    return;
                }

                // Clear input and add user message
                messageInput.value = '';
                messageInput.style.height = 'auto';
                this.addMessage('user', message);

                // Start processing
                this.isProcessing = true;
                this.updateSendButton(true);

                try {
                    // Initialize reasoning chain
                    this.reasoningChain = [];
                    this.addReasoningStep('INIT', 'Starting conversation processing');

                    // Analyze user intent and extract goals
                    await this.analyzeUserIntent(message);

                    // Retrieve relevant memory
                    const relevantMemory = this.retrieveRelevantMemory(message);
                    this.addReasoningStep('MEMORY', `Retrieved ${relevantMemory.length} relevant memories`);

                    // Execute iterative reasoning
                    const response = await this.executeIterativeReasoning(message, relevantMemory);

                    // Add assistant message
                    this.addMessage('assistant', response);

                    // Store conversation and update memory
                    this.storeConversation(message, response);
                    this.updateMemoryStore(message, response);

                } catch (error) {
                    console.error('Error:', error);
                    this.addMessage('system', `Error: ${error.message}`);
                } finally {
                    this.isProcessing = false;
                    this.updateSendButton(false);
                }
            }

            async analyzeUserIntent(message) {
                this.addReasoningStep('INTENT', 'Analyzing user intent and extracting goals');

                // Simple intent analysis - in a real implementation, this would be more sophisticated
                if (message.toLowerCase().includes('goal') || message.toLowerCase().includes('objective')) {
                    const goal = {
                        id: Date.now(),
                        description: message,
                        status: 'active',
                        created: new Date().toISOString()
                    };

                    this.goalsStore.push(goal);
                    localStorage.setItem('goals_store', JSON.stringify(this.goalsStore));
                    this.renderGoalsList();

                    this.addReasoningStep('GOAL', `New goal identified: ${message.substring(0, 50)}...`);
                }
            }

            retrieveRelevantMemory(query) {
                // Simple keyword matching - in a real implementation, this would use embeddings
                const keywords = query.toLowerCase().split(' ').filter(word => word.length > 3);

                return this.memoryStore.filter(memory => 
                    keywords.some(keyword => 
                        memory.summary.toLowerCase().includes(keyword) ||
                        memory.detail.toLowerCase().includes(keyword)
                    )
                ).slice(0, 5); // Limit to top 5 relevant memories
            }

            async executeIterativeReasoning(message, relevantMemory) {
                this.addReasoningStep('REASONING', 'Starting iterative reasoning process');

                // Build context for the API call
                let context = this.buildContext(message, relevantMemory);

                // First reasoning iteration
                let response = await this.callGeminiAPI(context);
                this.addReasoningStep('API_CALL_1', `Initial response generated (${response.length} chars)`);

                // Verification step
                const verification = await this.verifyResponse(message, response);
                this.addReasoningStep('VERIFY', `Verification: ${verification.status}`);

                if (verification.status === 'needs_improvement') {
                    this.addReasoningStep('ITERATE', 'Response needs improvement, generating enhanced version');

                    // Enhanced context with verification feedback
                    const enhancedContext = context + `\n\nPREVIOUS RESPONSE: ${response}\n\nIMPROVEMENT NEEDED: ${verification.feedback}\n\nProvide an improved response:`;

                    response = await this.callGeminiAPI(enhancedContext);
                    this.addReasoningStep('API_CALL_2', `Improved response generated`);
                }

                this.addReasoningStep('COMPLETE', 'Reasoning process completed');

                return response;
            }

            buildContext(message, relevantMemory) {
                let context = '';

                // Add system instructions
                if (this.systemInstructions) {
                    context += `SYSTEM: ${this.systemInstructions}\n\n`;
                }

                // Add goals context
                if (this.goalsStore.length > 0) {
                    context += `GOALS:\n${this.goalsStore.map(g => `- ${g.description}`).join('\n')}\n\n`;
                }

                // Add relevant memory
                if (relevantMemory.length > 0) {
                    context += `RELEVANT MEMORY:\n${relevantMemory.map(m => `- ${m.summary}: ${m.detail}`).join('\n')}\n\n`;
                }

                // Add recent conversation history
                const recentHistory = this.conversationHistory.slice(-5);
                if (recentHistory.length > 0) {
                    context += `RECENT CONVERSATION:\n${recentHistory.map(h => `User: ${h.user}\nAssistant: ${h.assistant}`).join('\n\n')}\n\n`;
                }

                // Add current message
                context += `CURRENT MESSAGE: ${message}\n\nRespond based on the above context and goals:`;

                return context;
            }

            async callGeminiAPI(content) {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-goog-api-key': this.apiKey
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: content
                            }]
                        }],
                        generationConfig: {
                            temperature: this.temperature,
                            maxOutputTokens: this.maxTokens,
                            topP: 1,
                            topK: 1
                        },
                        safetySettings: [
                            {
                                category: 'HARM_CATEGORY_HARASSMENT',
                                threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                            },
                            {
                                category: 'HARM_CATEGORY_HATE_SPEECH',
                                threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                            }
                        ]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                if (!data.candidates || data.candidates.length === 0) {
                    throw new Error('No response generated');
                }

                return data.candidates[0].content.parts[0].text;
            }

            async verifyResponse(originalMessage, response) {
                this.addReasoningStep('VERIFY_START', 'Verifying response quality and goal alignment');

                // Check goals alignment
                const goalsCheck = this.goalsStore.some(goal => 
                    response.toLowerCase().includes(goal.description.toLowerCase().split(' ')[0])
                );

                // Check response completeness (simple heuristic)
                const isComplete = response.length > 50 && !response.endsWith('...');

                // Check if response addresses the question
                const addressesQuestion = response.length > 20; // Simple check

                if (goalsCheck && isComplete && addressesQuestion) {
                    return { status: 'passed', feedback: 'Response meets quality standards' };
                } else {
                    let feedback = 'Issues found: ';
                    if (!goalsCheck) feedback += 'Not aligned with goals. ';
                    if (!isComplete) feedback += 'Response appears incomplete. ';
                    if (!addressesQuestion) feedback += 'Does not adequately address the question. ';

                    return { status: 'needs_improvement', feedback };
                }
            }

            storeConversation(userMessage, assistantResponse) {
                const conversation = {
                    user: userMessage,
                    assistant: assistantResponse,
                    timestamp: new Date().toISOString()
                };

                this.conversationHistory.push(conversation);

                // Keep only last 50 conversations
                if (this.conversationHistory.length > 50) {
                    this.conversationHistory = this.conversationHistory.slice(-50);
                }

                localStorage.setItem('conversation_history', JSON.stringify(this.conversationHistory));
            }

            updateMemoryStore(userMessage, assistantResponse) {
                // Generate memory summary
                const summary = userMessage.length > 50 ? userMessage.substring(0, 47) + '...' : userMessage;

                const memory = {
                    id: Date.now(),
                    summary: summary,
                    detail: `User asked: "${userMessage}" Assistant responded with information about: ${assistantResponse.substring(0, 100)}...`,
                    timestamp: new Date().toISOString(),
                    accessCount: 0
                };

                this.memoryStore.push(memory);

                // Keep only last 100 memories
                if (this.memoryStore.length > 100) {
                    this.memoryStore = this.memoryStore.slice(-100);
                }

                localStorage.setItem('memory_store', JSON.stringify(this.memoryStore));
                this.renderMemoryList();
            }

            addMessage(type, content) {
                const messagesContainer = document.getElementById('chatMessages');
                const messageElement = document.createElement('div');
                messageElement.className = `message ${type}`;

                if (type === 'assistant') {
                    // Parse markdown-like formatting for code blocks
                    content = this.parseCodeBlocks(content);
                }

                messageElement.innerHTML = content;
                messagesContainer.appendChild(messageElement);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            showSystemMessage(content) {
                this.addMessage('system', content);
            }

            parseCodeBlocks(content) {
                // Simple code block parsing
                return content.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                             .replace(/`([^`]+)`/g, '<code>$1</code>');
            }

            addReasoningStep(type, description) {
                const step = {
                    type: type,
                    description: description,
                    timestamp: new Date().toLocaleTimeString()
                };

                this.reasoningChain.push(step);

                const chainContainer = document.getElementById('reasoningChain');
                const stepElement = document.createElement('div');
                stepElement.className = 'chain-step';
                stepElement.innerHTML = `
                    <div class="step-header">${type}</div>
                    <div>${description}</div>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">${step.timestamp}</div>
                `;

                chainContainer.appendChild(stepElement);
                chainContainer.scrollTop = chainContainer.scrollHeight;
            }

            renderMemoryList() {
                const container = document.getElementById('memoryList');
                container.innerHTML = '';

                this.memoryStore.slice(-20).reverse().forEach(memory => {
                    const item = document.createElement('div');
                    item.className = 'memory-item';
                    item.innerHTML = `
                        <div class="memory-summary">${memory.summary}</div>
                        <div class="memory-detail">${memory.detail.substring(0, 80)}...</div>
                    `;
                    item.addEventListener('click', () => this.viewMemoryDetail(memory));
                    container.appendChild(item);
                });
            }

            renderGoalsList() {
                const container = document.getElementById('goalsList');
                container.innerHTML = '';

                this.goalsStore.forEach(goal => {
                    const item = document.createElement('div');
                    item.className = 'goal-item';
                    item.innerHTML = `
                        <div class="memory-summary">Goal: ${goal.status}</div>
                        <div class="memory-detail">${goal.description.substring(0, 60)}...</div>
                    `;
                    container.appendChild(item);
                });
            }

            renderConversationHistory() {
                const messagesContainer = document.getElementById('chatMessages');
                messagesContainer.innerHTML = '';

                // Show last 10 conversations
                this.conversationHistory.slice(-10).forEach(conv => {
                    this.addMessage('user', conv.user);
                    this.addMessage('assistant', conv.assistant);
                });
            }

            viewMemoryDetail(memory) {
                this.addMessage('system', `MEMORY DETAIL:\nSummary: ${memory.summary}\nDetail: ${memory.detail}\nTimestamp: ${memory.timestamp}`);
                memory.accessCount++;
                localStorage.setItem('memory_store', JSON.stringify(this.memoryStore));
            }

            updateSendButton(processing) {
                const button = document.getElementById('sendButton');
                button.disabled = processing;
                button.textContent = processing ? 'Processing...' : 'Send';
            }

            async executeCode() {
                const code = document.getElementById('codeEditor').value;
                if (!code.trim()) return;

                this.addReasoningStep('CODE_EXEC', 'Executing JavaScript code');

                try {
                    // Create a safe execution context
                    const result = await this.safeCodeExecution(code);
                    this.addMessage('system', `Code executed successfully:\n${result}`);
                } catch (error) {
                    this.addMessage('system', `Code execution error:\n${error.message}`);
                }
            }

            async safeCodeExecution(code) {
                // Create a promise that resolves with the execution result
                return new Promise((resolve, reject) => {
                    try {
                        // Capture console output
                        let output = [];
                        const originalConsole = console.log;
                        console.log = (...args) => {
                            output.push(args.map(arg => 
                                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                            ).join(' '));
                            originalConsole(...args);
                        };

                        // Execute code
                        const result = eval(`(async function() { ${code} })()`);

                        // Restore console
                        console.log = originalConsole;

                        if (result instanceof Promise) {
                            result.then(res => {
                                resolve(output.length > 0 ? output.join('\n') : String(res || 'undefined'));
                            }).catch(reject);
                        } else {
                            resolve(output.length > 0 ? output.join('\n') : String(result || 'undefined'));
                        }
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            renderCanvas() {
                const code = document.getElementById('codeEditor').value;
                if (!code.trim()) return;

                const frame = document.getElementById('canvasFrame');
                const html = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="UTF-8">
                        <style>
                            body { font-family: 'Geist', sans-serif; margin: 20px; }
                            * { box-sizing: border-box; }
                        </style>
                    </head>
                    <body>
                        ${code}
                    </body>
                    </html>
                `;

                frame.src = 'data:text/html;charset=utf-8,' + encodeURIComponent(html);
                this.addReasoningStep('CANVAS', 'HTML content rendered in canvas');
            }

            saveConfiguration() {
                this.apiKey = document.getElementById('apiKeyInput').value;
                this.model = document.getElementById('modelSelect').value;
                this.temperature = parseFloat(document.getElementById('temperatureInput').value);
                this.maxTokens = parseInt(document.getElementById('maxTokensInput').value);
                this.systemInstructions = document.getElementById('systemPrompt').value;

                // Save to localStorage
                localStorage.setItem('gemini_api_key', this.apiKey);
                localStorage.setItem('gemini_model', this.model);
                localStorage.setItem('gemini_temperature', this.temperature);
                localStorage.setItem('gemini_max_tokens', this.maxTokens);
                localStorage.setItem('gemini_system', this.systemInstructions);

                this.updateStatus();
                this.showSystemMessage('Configuration saved successfully');
            }
        }

        // Initialize the interface when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.geminiInterface = new GeminiInterface();
        });
    </script>
</body>
</html>
