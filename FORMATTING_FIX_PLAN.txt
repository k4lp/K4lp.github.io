FORMATTING RELIABILITY PLAN
===========================
Goal: stop LLM responses (reasoning log, storage entities, final output) from being truncated when they contain Markdown, `>` characters, or vault references embedded in tool attributes.

1. Deep audit
   - Map the entire pipeline: tool patterns (js/config/tool-registry-config.js), unified-tool-parser extraction, parseAttributes(), downstream processors, and rendering/storage. Note every place that assumes attributes end before the next `>`.
   - Record findings in TEMP_KNOWLEDGE.txt for traceability.

2. Pattern hardening
   - Replace all literal regexes for self-closing and block tools with helpers that build `{{<tag ... />}}` and `{{<tag ...>}}...{{</tag>}}` patterns using `([\s\S]*?)` between the tag name and closing delimiter. Centralise in tool-registry-config.js so every tool benefits and future additions stay safe.
   - Ensure datavault block pattern also uses the helper so both attribute and inner content handling are consistent.

3. Attribute parsing resiliency
   - Upgrade `parseAttributes()` to a small state machine that walks the attribute blob character-by-character, honours quoted values with embedded `>`/newlines, and understands escaped quotes. Fall back to existing regex only for legacy flags. This guarantees we actually capture the full `content="..."` payload once the broader regex hands it off.

4. Validation & telemetry
   - Add a warning hook inside unified-tool-parser.extractByPattern() that logs when an attribute blob appears truncated (e.g., unbalanced quotes, stray `{{}}`). This will surface future regressions directly in the console.
   - Extend PLAN_VERIFICATION with the scenarios we will re-test (long Markdown task content, vaultref-heavy final_output) and capture before/after lengths in PROGRESS_TRACKER.

5. Implementation order
   1) Introduce the pattern builder + apply across memory/task/goal/datavault.
   2) Implement the resilient attribute parser + wire it into parseAttributes().
   3) Add the truncation telemetry in unified-tool-parser.
   4) Run manual fixtures (JS snippet) to prove that `{{<task content="Line A > Line B" />}}` and multiline vault entries survive end-to-end.

6. Cross-verification
   - After coding, update PLAN_VERIFICATION.txt with the inspected files/line ranges and the fixture results.
   - Log each milestone in PROGRESS_TRACKER.txt per compliance requirements.
